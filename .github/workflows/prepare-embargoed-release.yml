name: Prepare embargoed Git for Windows release

on:
  workflow_dispatch:
    inputs:
      git_artifacts_i686_workflow_run_id:
        description: 'ID of the git-artifacts (i686) workflow run'
        required: true
      git_artifacts_x86_64_workflow_run_id:
        description: 'ID of the git-artifacts (x86_64) workflow run'
        required: true

env:
  GIT_CONFIG_PARAMETERS: "'user.name=gitforwindowshelper-bot' 'user.email=gitforwindowshelper-bot@users.noreply.github.com'"
  HOME: "${{github.workspace}}/home"
  OWNER: "${{ github.repository_owner }}"
  REPO: git
  I686_WORKFLOW_RUN_ID: "${{ github.event.inputs.git_artifacts_i686_workflow_run_id }}"
  X86_64_WORKFLOW_RUN_ID: "${{ github.event.inputs.git_artifacts_x86_64_workflow_run_id }}"

jobs:
  prepare-github-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Download workflow run artifacts
        id: download-artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const [owner, repo] = '${{ github.repository }}'.split('/')
            const appId = ${{ secrets.GH_APP_ID }}
            const privateKey = `${{ secrets.GH_APP_PRIVATE_KEY }}`

            const getAppInstallationId = require('./get-app-installation-id')
            const installationId = await getAppInstallationId(
              console,
              appId,
              privateKey,
              owner,
              repo
            )

            const getInstallationAccessToken = require('./get-installation-access-token')
            const { token } = await getInstallationAccessToken(
              console,
              appId,
              privateKey,
              installationId
            )
            core.setSecret(token)

            const { getWorkflowRunArtifactsURLs, download } = require('./github-release')
            const result = []
            for (const architecture of ['i686', 'x86_64']) {
              const workflowRunId = process.env[`${architecture.toUpperCase()}_WORKFLOW_RUN_ID`]
              const urls = await getWorkflowRunArtifactsURLs(console, token, owner, repo, workflowRunId)
              for (const name of Object.keys(urls)) {
                const outputFileName = name.endsWith(`-${architecture}`) ? `${name}.zip` : `${name}-${architecture}.zip`
                console.log(`Downloading ${outputFileName}`)
                await download(token, urls[name], outputFileName)
                result.push(outputFileName)
              }
            }
            return result
      - name: Unpack some artifacts and extract some information
        id: info
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            // TODO: update `pushRepositoryUpdate()` to allow for `/prepare-embargoed-git` and `/publish-embargoed-git`
            // TODO: merge `/publish-embargoed-git` into `/release`...
            // TODO: update the repository-updates to pick up the release branches and push those as updates instead of the bundles
            const { unzip } = require('./github-release')
            await unzip(`bundle-artifacts-x86_64.zip`, `bundle-artifacts`)
            const fs = require('fs')
            core.setOutput('release-branch', fs.readFileSync('bundle-artifacts/release-branch', 'utf8').trim())
            const result = fs.readFileSync('bundle-artifacts/next_version', 'utf8').trim()
            core.setOutput('tag-name', result)
            const ver = fs.readFileSync('bundle-artifacts/ver', 'utf8').trim()
            const releaseNotes = fs.readFileSync(`bundle-artifacts/release-notes-${ver}`, 'utf8').trim()
            core.setOutput('release-notes', releaseNotes)
            const mingitOnly = fs.existsSync('bundle-artifacts/mingit-only')
            core.setOutput('mingit-only', mingitOnly ? 'true' : 'false')

            for (const name of [
              'pkg-x86_64', // For MINGW-packages.bundle
              'installer-x86_64', // For versions/package-versions-$ver.txt
              'mingit-x86_64' // For versions/package-versions-$ver-MinGit.txt
            ]) await unzip(`${name}.zip`, name)

            return result
      - name: configure token
        if: github.repository_visibility == 'private'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            if (!fs.existsSync(process.env.HOME)) fs.mkdirSync(process.env.HOME)
            const { callGit, getPushAuthorizationHeader } = require('./repository-updates.js')
            for (const repo of ['git', 'build-extra', 'MINGW-packages']) {
              const header = await getPushAuthorizationHeader(
                console,
                core.setSecret,
                ${{ secrets.GH_APP_ID }},
                ${{ toJSON(secrets.GH_APP_PRIVATE_KEY) }},
                process.env.OWNER,
                repo
              )
              console.log(callGit(['config', '--global', `http.https://github.com/${process.env.OWNER}/${repo}.extraHeader`, header]))
            }
      - name: push repository updates
        uses: actions/github-script@v7
        with:
          script: |
            const { pushRepositoryUpdate } = require('./repository-updates.js')
            const doPush = async (repo, refName, bundlePath, extraPushRefs) => {
              await pushRepositoryUpdate(
                console,
                core.setSecret,
                ${{ secrets.GH_APP_ID || 1 }},
                ${{ toJSON(secrets.GH_APP_PRIVATE_KEY) }},
                owner,
                repo,
                refName,
                bundlePath,
                extraPushRefs
              )
            }
            const owner = process.env.OWNER
            const releaseBranch = '${{ steps.info.outputs.release-branch }}'
            const tagName = '${{ steps.info.outputs.tag-name }}'
            await doPush('git', releaseBranch, 'bundle-artifacts/git.bundle', { extraPushRefs: [`refs/tags/${tagName}`] })
            await doPush('build-extra', releaseBranch, 'bundle-artifacts/build-extra.bundle', { mingitOnly: ${{ steps.info.outputs.mingit-only }} })
            await doPush('MINGW-packages', releaseBranch, 'pkg-x86_64/MINGW-packages.bundle')
      - name: create release and upload release assets
        uses: actions/github-script@v7
        with:
          script: |
            const {
              createRelease,
              uploadGitArtifacts,
              pushGitTag,
              updateRelease
            } = require('./github-release')

            const { initCheckRunState } = require('./check-runs')
            const state = await initCheckRunState(
              console,
              core.setSecret,
              ${{ secrets.GH_APP_ID }},
              ${{ toJSON(secrets.GH_APP_PRIVATE_KEY) }},
              process.env.OWNER,
              process.env.REPO)
            await state.refreshToken()

            const release = await createRelease(
              console,
              state.accessToken,
              process.env.OWNER,
              process.env.REPO,
              '${{ steps.info.outputs.tag-name }}',
              '${{ steps.info.outputs.git-rev }}',
              '${{ steps.info.outputs.mingit-only == 'true' && 'Min' || '' }}Git for Windows ${{ steps.info.outputs.display-version }}',
              ${{ toJSON(steps.info.outputs.release-notes) }}
            )
            await state.refreshToken()

            const artifacts = ${{ steps.download-artifacts.outputs.result }}
              .map(name => { return { name, path: name } })
            await uploadGitArtifacts(
              console,
              state.accessToken,
              process.env.OWNER,
              process.env.REPO,
              release.id,
              artifacts
            )
            await state.refreshToken()

            console.log('Publishing release')
            await updateRelease(
              console,
              state.accessToken,
              process.env.OWNER,
              process.env.REPO,
              release.id, {
                draft: false,
                prerelease: true,
                make_latest : false
              }
            )
