name: build-and-deploy
run-name: Test quick-add

on:
  push:

env:
  PACKAGE_TO_BUILD: "mingw-w64-git"
  BUILD_ONLY: "true"
  OWNER: "git-for-windows"
  REPO: "MINGW-packages"
  REF: "147af4445ca6af015b88dd87a466591d88324e2a"
  ARCHITECTURE: "aarch64"
  GPG_OPTIONS: "--batch --yes --no-tty --list-options no-show-photos --verify-options no-show-photos --pinentry-mode loopback"
  HOME: "${{ github.workspace }}\\home"
  ACTOR: "${{ github.event.inputs.actor || github.triggering_actor }}"
  CREATE_CHECK_RUN: false

jobs:
  build:
    runs-on: ${{ fromJSON('["Windows", "ARM64"]') }}
    steps:
      - uses: actions/checkout@v3

      - name: reuse artifact
        shell: bash
        run: |
          run_id=4111902435 &&
          name=artifacts &&

          curl -L https://api.github.com/repos/${{github.repository}}/actions/runs/$run_id/artifacts |
          sed -n '/^    {/{        # start of item
            :1
            N                      # read next line
            /\n    }/{             # end of item
              # if the item has the intended name, print it as well as the URL
              s/.*"name": "\('$name'\)".*"archive_download_url": "\([^"]*\).*/\1 \2/p
              # theoretically the `name` and `archive_download_url` could be displayed in reverse order
              s/.*"archive_download_url": "\([^"]*\).*"name": "\('$name'\)".*/\1 \2/p
              b                    # the item was handled
            }
            b1                     # keep reading until end of item
          }' |
          while read name url
          do
            echo "$name"
            curl -H "Authorization: token ${{secrets.GITHUB_TOKEN}}" \
              -#sLo /tmp/"$name".zip "$url" &&
            mkdir "$name" &&
            unzip -q -d "$name" /tmp/"$name".zip
          done

      - name: Download Git for Windows SDK
        uses: git-for-windows/setup-git-for-windows-sdk@6697295a149f95f97cb98aff3c2316cf264f7b80
        with:
          flavor: ${{ env.PACKAGE_TO_BUILD == 'mingw-w64-git' && 'build-installers' || 'full' }}
          architecture: ${{ env.ARCHITECTURE || 'x86_64' }}
          msys: ${{ env.REPO == 'MSYS2-packages' || env.PACKAGE_TO_BUILD == 'git-for-windows-keyring' }}

      - name: Clone build-extra (unless cloned already)
        if: env.REPO != 'build-extra'
        shell: bash
        run: git clone --depth 1 --single-branch -b main https://github.com/git-for-windows/build-extra /usr/src/build-extra

      - name: ${{ env.BUILD_ONLY == 'true' && 'Test-deploy' || 'Deploy' }} Pacman packages
        if: env.BUILD_ONLY == 'true' || env.AZURE_BLOBS_TOKEN != ''
        shell: bash
        env:
          PACMANDRYRUN: ${{env.BUILD_ONLY}}
        run: /usr/src/build-extra/pacman-helper.sh quick_add artifacts/*

      - name: action-tmate
        if: failure()
        shell: bash
        run: |
          # install tmate
          pacman -Sy --noconfirm tmate openssh &&

          # restrict SSH access to the "actor", i.e. the GitHub user who triggered this workflow
          # this requires calling `ssh -i <private-key> [...]` later on
          mkdir -p ~/.ssh &&
          curl https://api.github.com/users/${{github.actor}}/keys | jq -r '.[].key' >~/.ssh/authorized_keys &&

          # Generate an SSH key (needed for tmate)
          echo -e 'y\n' | ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &&

          # Start tmate session
          export CHERE_INVOKING=1 &&
          tmate -S /tmp/tmate.sock -a ~/.ssh/authorized_keys new-session -d &&
          tmate -S /tmp/tmate.sock wait tmate-ready &&

          # Print SSH invocation every 5 seconds, until tmate session has terminated
          while test -e /tmp/tmate.sock
          do
            tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}'
            sleep 5
          done
